/* * Name: Tych Panel 0.9.6 * Author: Reimund Trost (c) 2011 * Email: reimund@lumens.se * Website: http://lumens.se/tychpanel/ * * Description: This set of scripts automates the creation of diptychs, * triptychs, quaptychs and even n-tychs.  * * The script makes at least the following * assumptions: * *  - One image per layer. *  - Images are placed at (0,0). *  - There are as many layers as the corresponding tych variant, ie. two *    layers for diptych, three layers for triptych and so on. *///@include Tych%20Panel%20Options%20Only/tpconstants.jsx//@include Tych%20Panel%20Options%20Only/tpsettings.jsx// XXX: More layouts: 3x2, 3x3, 3x4, 4x2, 4x3, 4x4 etc.// XXX: Make spacing more exact. Inaccuriacies most probably caused by rounding// errors and perhaps blurry edges after resizing.// XXX: Keep aspect ratio option does not affect all tychs (currently only// n-tychs). Not really a problem since the icon buttons are a different use// case, however, it can be a bit non-obvious for some users.// XXX: Ability to apply post- and pre-processing actions.// XXX: Fix bugs on windows. For now, the duplicate-workaround will do.// XXX: Add ability to sort images with previews before they get stacked.// XXX: Use own stack script instead of Adobes.// XXX: Custom background color.var tpSettings = tpGetSettings();var WHITE = new Array(255, 255, 255);//tpTych(5);//tpTych(Number(prompt("Tych variant?", 0, "Enter a number between 0 and 8")));//tpComposite();function tpComposite(){	// Save current unit preferences.	var rulerUnits = preferences.rulerUnits;	// Change unit preferences.	preferences.rulerUnits = Units.PIXELS;	var	doc = documents.length > 0 ? activeDocument : null;	var images = File.openDialog("Choose file(s) to add to composite", undefined, true);	var stackDoc = tpStack(images);	tpNTych(stackDoc);	if (tpSettings.autosave)		save(stackDoc);	// If there was no active document when we started we just have to fill the	// background and then we're done.	if (doc == null) {		tpAddBackground(stackDoc, WHITE);		return;	}			tpPlaceComp(stackDoc, doc);		if (doc.layers[doc.layers.length - 1].name == 'Background')		tpFillBackground(doc, WHITE);	else 		tpAddBackground(doc, WHITE);		if (tpSettings.autosave)		save(doc);	// Revert settings.	preferences.rulerUnits = rulerUnits;}/** * Places the contents of one document at the bottom of another. */function tpPlaceComp(src, target){	var srcHeight = src.height;	var targetHeight = target.height;	// Unlock the background (if locked) so we can put a background fill below.	target.layers[target.layers.length - 1].isBackgroundLayer = false;	activeDocument = src;	src.selection.selectAll();	src.selection.copy(true);	src.close(SaveOptions.DONOTSAVECHANGES);	activeDocument = target;	target.activeLayer = target.layers[0];		// Get rid of outside pixels;	target.crop([0, 0, target.width, target.height]);	target.paste();	target.resizeCanvas(target.width, target.height + srcHeight + tpSettings.spacing, AnchorPosition.TOPLEFT);	// XXX: Why don't I use translate here?	target.layers[0].applyOffset(0, targetHeight - target.activeLayer.bounds[1] + tpSettings.spacing, OffsetUndefinedAreas.SETTOBACKGROUND);}/** * Stacks the specified images. */function tpStack(images){	var doc = app.open(images[0]);	doc.layers[0].isBackgroundLayer = false;	f = function() {		var d = doc;		var maxx = doc.width;		var maxy = doc.height;		for (i = 0; i < images.length; i++) {			if (i > 0) {				d = app.open(images[i]);				d.selection.selectAll();				if (d.layers.length > 1)					d.selection.copy(true);				else					d.selection.copy();				maxx = Math.max(maxx, d.width);				maxy = Math.max(maxy, d.height);				d.close(SaveOptions.DONOTSAVECHANGES);				activeDocument = doc;				doc.paste();				doc.layers[0].translate(-doc.layers[0].bounds[0].value, -doc.layers[0].bounds[1].value);			}		}		doc.resizeCanvas(maxx, maxy, AnchorPosition.TOPLEFT);	}	doc.suspendHistory('Stack images', 'f()');	return doc;}/** * Pads the given number n with l zeroes. */function zeropad(n, l) {	n = n.toString();	l = Number(l);	var pad = '0';	while (n.length < l) {n = pad + n;}	return n;}/** * Saves the specified document to the directory and filename set in the * options dialog. If the file exists a sequential number will be appended. */function save(doc){	var basename = tpSettings.filename;	var paddedName = basename + '_001';	var jpgFile = new File(tpSettings.save_directory + '/' + paddedName + '.jpg');	var padding;		// XXX: Add a timeout perhaps...	// If the file exist, increase the sequential number by 1.	while (jpgFile.exists) {		padding = paddedName.substr(paddedName.lastIndexOf('_') + 1);		paddedName = basename + '_' + zeropad(Number(padding) + 1, 3);		jpgFile = new File(tpSettings.save_directory + '/' + paddedName + '.jpg');	}	jpgSaveOptions = new JPEGSaveOptions();	jpgSaveOptions.embedColorProfile = true;	jpgSaveOptions.formatOptions = FormatOptions.STANDARDBASELINE;	jpgSaveOptions.matte = MatteType.NONE;	jpgSaveOptions.quality = tpSettings.jpeg_quality;	doc.saveAs(jpgFile, jpgSaveOptions, true, Extension.LOWERCASE);}/** * Makes a tych of the current active document. */function tpTych(tych_variant){	if (documents.length > 0) {		// Ugly workaround for Windows bug. If we use the original document		// weird things start to happen for no apparent reason. So we use a		// duplicate instead.		var d = activeDocument;		var doc = d.duplicate();		var required = -1;		d.close(SaveOptions.DONOTSAVECHANGES);		if (tych_variant < 3) {			if (doc.layers.length < 2)				required = 2;		} else if (tych_variant > 2 && tych_variant < 6) {			if (doc.layers.length < 3)				required = 3;		} else {			if (doc.layers.length < 4)				required = 4;		}				if (required > 0) {			alert('This action requires ' + required + ' layers. Stack some more layers then try again.');			return -1;		}					doc.suspendHistory(tpTychToHistoryName(tych_variant), 'makeTych(tych_variant, activeDocument)');		//makeTych(tych_variant, activeDocument);		tpApplyResize(doc);		if (tpSettings.autosave)			save(doc);		if (tpSettings.autoclose)			doc.close(SaveOptions.DONOTSAVECHANGES);	} else {		alert("You have to open a document to use this script.");		return -1;	}}/** * Makes an horizontal n-tych by spacing out the layers in the specified * document. */function tpNTych(doc){	// Compute the width of the all layers side by side. The width will affect the	// spacing between layers. Wheter aspect ratio is kept or not will affect	// how wide the final image will be thus it will also affect the spacing.	var height = tpSettings.keep_aspect ? tpMinHeight(doc.layers) : null;	var width = tpSumWidthAtHeight(doc.layers, doc.layers.length, height)		var spacing = tpSettings.resize		? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / width))		: tpSettings.spacing;	var size = tpGetSize(doc.layers, spacing);	var trans = tpGetTrans(doc.layers, spacing);	tpArrange(doc, trans);	doc.resizeCanvas(size[0], size[1], AnchorPosition.TOPLEFT);	tpApplyResize(doc);}/** * Computes the dimensions of a horizontally arranged n-tych for the given * layers. */function tpGetSize(layers, spacing){	var minh = tpMinHeight(layers);	if (tpSettings.keep_aspect)		return new Array(tpSumWidthAtHeight(layers, layers.length, minh) + spacing * (layers.length - 1), minh);	else		return new Array(tpSumWidth(layers) + spacing * (layers.length - 1), minh);}/** * Computes the transformation matrix for placing the given layers * horizontally. */function tpGetTrans(layers, spacing){	var trans = new Array();	var minh = tpMinHeight(layers);	var l = layers;	var s;	for (var i = 0; i < layers.length; i++) {		if (tpSettings.keep_aspect) {			s = minh / (l[i].bounds[3].value - l[i].bounds[1].value);			trans.push(				new Array(					new Array(s * 100, s * 100, AnchorPosition.TOPLEFT),					new Array(tpSumWidthAtHeight(l, i, minh) + spacing * i, 0)				)			);		} else {			trans.push(new Array(null, new Array(tpSumWidth(l, i) + spacing * i, -(l[i].bounds[3] - minh) / 2)));		}	}	return trans;}/** * Arranges the layers in the specified documents according to the specified * transformations t. */function tpArrange(doc, t){	for(i = 0; i < doc.layers.length; i++) {		if (i >= t.length) break;				// Check if the layer should be resized.		if (t[i][0] != null)			doc.layers[i].resize(t[i][0][0], t[i][0][1], t[i][0][2]);		// Check if the layer should be moved.		if (t[i][1] != null) {			doc.layers[i].translate(t[i][1][0], t[i][1][1]);		}	}}/** * Makes a tych of the specified variant for a given document. */function makeTych(tych_variant, doc){	var width = Number(doc.width);	var height = Number(doc.height);	var spacing = tpSettings.spacing;	var new_size;	var trans;	// Unlock the background layer, if it exists. We do this because since	// we need to move a layer underneath it later.	doc.layers[doc.layers.length - 1].isBackgroundLayer = false;	switch (tych_variant) {		case DIPTYCH_HORIZONTAL:		case TRIPTYCH_HORIZONTAL:		case QUAPTYCH_HORIZONTAL:			var spacing = tpSettings.resize				? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / tpSumWidth(doc.layers)))				: tpSettings.spacing;			var new_size = tpGetSize(doc.layers, spacing);			var trans = tpGetTrans(doc.layers, spacing);			break;		case DIPTYCH_LANDSCAPE_PORTRAIT_HORIZONTAL:		case DIPTYCH_PORTRAIT_LANDSCAPE_HORIZONTAL:			// Index of portrait layer.			var p = doc.layers[0].bounds[2] > doc.layers[1].bounds[2] ? 1 : 0;						// Scale factor.			var s = doc.layers[1 - p].bounds[3] / doc.layers[p].bounds[3];			var resize = new Array(new Array(s * 100, s * 100, AnchorPosition.TOPLEFT), null);			var offset_x = tych_variant == DIPTYCH_LANDSCAPE_PORTRAIT_HORIZONTAL 				? new Array(doc.layers[1 - p].bounds[2] + spacing, 0) : new Array(0, s * doc.layers[p].bounds[2] + spacing);			trans = new Array(				new Array(resize[p], new Array(offset_x[p], 0)),				new Array(resize[1 - p], new Array(offset_x[1 - p], 0))			)			new_size = new Array(doc.layers[1 - p].bounds[2] + doc.layers[p].bounds[2] * s + spacing, doc.layers[1 - p].bounds[3]);			break;		case TRIPTYCH_PORTRAIT_LANDSCAPE_GRID:		case TRIPTYCH_LANDSCAPE_PORTRAIT_GRID:			// Index of portrait layer.			var p = doc.layers[0].bounds[3] > doc.layers[1].bounds[3] ? 0 : 2;			p = doc.layers[1].bounds[3] > doc.layers[2].bounds[3] ? 1 : p;			var spacing = tpSettings.resize				? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / (doc.layers[p].bounds[2] * 2)))				: tpSettings.spacing;			trans = new Array(				new Array(null, new Array(0, 0)),				new Array(null, new Array(0, 0)),				new Array(null, new Array(0, 0))			)			var l;			if (p == 0)				l = new Array(1, 2);			else if (p == 1)				l = new Array(0, 2);			else				l = new Array(0, 1);			var offsetx = tych_variant == TRIPTYCH_PORTRAIT_LANDSCAPE_GRID ? doc.layers[p].bounds[2] + spacing : 0;			// Transformations for the first landscape image.			var s1 = doc.layers[p].bounds[2] / doc.layers[l[0]].bounds[2];			trans[l[0]] = new Array(				new Array(100 * s1, 100 * s1, AnchorPosition.TOPLEFT),				new Array(offsetx, 0)			);			// Transformations for the second landscape image.			var s2 = doc.layers[p].bounds[2] / doc.layers[l[1]].bounds[2];			trans[l[1]] = new Array(				new Array(100 * s2, 100 * s2, AnchorPosition.TOPLEFT),				new Array(offsetx, doc.layers[l[0]].bounds[3] * s1 + spacing)			);			// XXX: It would be better if the landscape images were adjusted			// vertically so that the seam is centered as much as the images			// allow.			new_size = new Array(				doc.layers[p].bounds[2].value * 2 + spacing,				Math.min(doc.layers[l[0]].bounds[3].value * s1 + doc.layers[l[1]].bounds[3].value * s2 + spacing, doc.layers[p].bounds[3].value)			);			trans[p][1][0] = tych_variant == TRIPTYCH_PORTRAIT_LANDSCAPE_GRID ? 0 : doc.layers[p].bounds[2] + spacing;			trans[p][1][1] = -(doc.layers[p].bounds[3] - new_size[1]) / 2;			break;		case QUAPTYCH_GRID:			var l = doc.layers;			var col1_width = Math.max(l[0].bounds[2].value, l[2].bounds[2].value);			var col2_width = Math.max(l[1].bounds[2].value, l[3].bounds[2].value);			var row1_height = Math.max(l[0].bounds[3].value, l[1].bounds[3].value);			var row2_height = Math.max(l[2].bounds[3].value, l[3].bounds[3].value);			var spacing = tpSettings.resize				? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / (col1_width + col2_width)))				: tpSettings.spacing;			trans = new Array(				new Array(null, null),				new Array(null, new Array(col1_width + spacing, 0)),				new Array(null, new Array(0, row1_height + spacing)),				new Array(null, new Array(col1_width + spacing, row1_height + spacing))			)			new_size = new Array(col1_width + col2_width + spacing, row1_height + row2_height + spacing);			break;		default:			return -1;	}	// Transform each layer according to the transformations specified in	// the trans variable.	tpArrange(doc, trans);		doc.resizeCanvas(new_size[0], new_size[1], AnchorPosition.TOPLEFT);	// Create a layer, put it last and it white.	var fillLayer = doc.artLayers.add();	fillLayer.move(doc.layers[doc.layers.length - 1], ElementPlacement.PLACEAFTER);	tpFillBackground(doc, WHITE);}/** * Resizes the specified document according to the user settings. */function tpApplyResize(doc){	if (tpSettings.resize) {		var resampleMethod = tpSettings.resample_method == 'bicubic' ? ResampleMethod.BICUBIC : ResampleMethod.BICUBICSHARPER;		doc.resizeImage(tpSettings.resize_width, tpSettings.resize_width * doc.height / doc.width, 1, resampleMethod);	}}/** * Make a background layer and fill it with the specified color. */function tpFillBackground(doc, color){	var al = doc.activeLayer;	var fillColor = new SolidColor();	fillColor.rgb.red = color[0];	fillColor.rgb.green = color[1];	fillColor.rgb.blue = color[2];		doc.activeLayer = doc.layers[doc.layers.length - 1];	doc.selection.fill(fillColor)	doc.activeLayer = al;}/** * Add a background layer and fill it with the specified color. */function tpAddBackground(doc, color){	doc.layers[doc.layers.length - 1].isBackgroundLayer = false;	doc.activeLayer = doc.layers[doc.layers.length - 1];	var fillLayer = doc.artLayers.add();	fillLayer.name = 'Background';	fillLayer.move(doc.layers[doc.layers.length - 1], ElementPlacement.PLACEAFTER);	tpFillBackground(doc, color);}/** * Computes the total width of the specified layers. */function tpSumWidth(layers, max){	var totalWidth = 0;	for (var i = 0; i < layers.length; i++) {		if (max != null && i == max) break;		totalWidth += layers[i].bounds[2].value - layers[i].bounds[0].value;	}	return totalWidth;}/** * Computes the total width of the specified layers as if they were scaled * (keeping aspect ratio) to fit the specified height. */function tpSumWidthAtHeight(layers, max, height) {	if (height == null) return tpSumWidth(layers, max);	var totalWidth = 0;	var s;	for (var i = 0; i < layers.length; i++) {		if (max != null && i == max) break;		s = height / (layers[i].bounds[3].value - layers[i].bounds[1].value);		totalWidth += s * (layers[i].bounds[2].value - layers[i].bounds[0].value);	}	return totalWidth;}/** * Gets the height of the shortest of the specified layers. */function tpMinHeight(layers){	var minWidth = Number.MAX_VALUE;	for (var i = 0; i < layers.length; i++)		minWidth = Math.min(minWidth, layers[i].bounds[3].value - layers[i].bounds[1].value);	return minWidth;}/** * Translates the specified tych variant constant into a human friendly string * for the history palette. */function tpTychToHistoryName(tych_variant){	switch (tych_variant) {		case DIPTYCH_HORIZONTAL:		case DIPTYCH_LANDSCAPE_PORTRAIT_HORIZONTAL:		case DIPTYCH_PORTRAIT_LANDSCAPE_HORIZONTAL:			return 'Create diptych';		case TRIPTYCH_HORIZONTAL:		case TRIPTYCH_PORTRAIT_LANDSCAPE_GRID:		case TRIPTYCH_LANDSCAPE_PORTRAIT_GRID:			return 'Create triptych';		case QUAPTYCH_HORIZONTAL:		case QUAPTYCH_GRID:			return 'Create quaptych';	}}