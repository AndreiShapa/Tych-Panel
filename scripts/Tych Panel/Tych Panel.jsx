/* * Name: Tych Panel 0.9.2 * Author: Reimund Trost (c) 2011 * Email: reimund@lumens.se * Website: http://lumens.se/tychpanel/ * * Description: This set of scripts automates the creation of diptychs, * triptychs, quaptychs and even n-tychs.  * * The script makes at least the following * assumptions: * *  - One image per layer. *  - Images are placed at (0,0). *  - There are as many layers as the corresponding tych variant, ie. two *    layers for diptych, three layers for triptych and so on. *///@include Tych%20Panel%20Options%20Only/tpconstants.jsx//@include Tych%20Panel%20Options%20Only/tpsettings.jsx// XXX: More layouts: 3x2, 3x3, 3x4, 4x2, 4x3, 4x4 etc.// XXX: Make spacing more exact. Inaccuriacies most probably caused by rounding// errors and perhaps blurry edges after resizing.// XXX: Keep aspect ratio option does not affect all tychs (currently only// n-tychs). Not really a problem since the icon buttons are a different use// case, however, it can be a bit non-obvious for some users.// XXX: Ability to apply post- and pre-processing actions.var tpSettings = tpGetSettings();var WHITE = new Array(255, 255, 255);//tpTych(5);//tpTych(Number(prompt("Tych variant?", 0, "Enter a number between 0 and 8")));//tpComposite();function tpComposite(){	// Save current unit preferences.	var rulerUnits = preferences.rulerUnits;	// Change unit preferences.	preferences.rulerUnits = Units.PIXELS;	var	doc = documents.length > 0 ? activeDocument : null;	var images = File.openDialog("Choose file(s) to add to composite", undefined, true);	var stackDoc = app.documents.add();	tpStack(images, stackDoc);	tpNTych(stackDoc);	// If there was no active document when we started we just have to fill the	// background and then we're done.	if (doc == null) {		tpAddBackground(stackDoc, WHITE);		return;	}			tpPlaceComp(stackDoc, doc);		if (doc.layers[doc.layers.length - 1].name == 'Background')		tpFillBackground(doc, WHITE);	else 		tpAddBackground(doc, WHITE);	// Revert settings.	preferences.rulerUnits = rulerUnits;}/** * Places the contents of one document at the bottom of another. */function tpPlaceComp(src, target){	var srcHeight = src.height;	var targetHeight = target.height;	// Unlock the background (if locked) so we can put a background fill below.	tpUnlockBackground(target);	activeDocument = src;	src.selection.selectAll();	src.selection.copy(true);	src.close(SaveOptions.DONOTSAVECHANGES);	activeDocument = target;	target.activeLayer = target.layers[0];		// Get rid of outside pixels;	target.crop([0, 0, target.width, target.height]);	target.paste();	target.resizeCanvas(target.width, target.height + srcHeight + tpSettings.spacing, AnchorPosition.TOPLEFT);	// XXX: Why don't I use translate here?	target.layers[0].applyOffset(0, targetHeight - target.activeLayer.bounds[1] + tpSettings.spacing, OffsetUndefinedAreas.SETTOBACKGROUND);}/** * Stacks the specified images. */function tpStack(images, doc){	f = function() {		var d;		var maxx = 0;		var maxy = 0;		for (i in images) {			d = app.open(images[i]);			d.selection.selectAll();			if (d.layers.length > 1)				d.selection.copy(true);			else				d.selection.copy();			maxx = Math.max(maxx, d.width);			maxy = Math.max(maxy, d.height);			d.close(SaveOptions.DONOTSAVECHANGES);			activeDocument = doc;			doc.paste();			doc.layers[0].translate(-doc.layers[0].bounds[0].value, -doc.layers[0].bounds[1].value);		}		doc.resizeCanvas(maxx, maxy, AnchorPosition.TOPLEFT);		doc.artLayers[doc.layers.length - 1].remove();	}	doc.suspendHistory('Stack images', 'f()');}/** * Makes a tych of the current active document. */function tpTych(tych_variant){	if (documents.length > 0) {		var doc = activeDocument;		var required = -1;		if (tych_variant < 3) {			if (doc.layers.length < 2)				required = 2;		} else if (tych_variant > 2 && tych_variant < 6) {			if (doc.layers.length < 3)				required = 3;		} else {			if (doc.layers.length < 4)				required = 4;		}				if (required > 0) {			alert('This action requires ' + required + ' layers. Stack some more layers then try again.');			return -1;		}					doc.suspendHistory(tpTychToHistoryName(tych_variant), 'makeTych(tych_variant, activeDocument)');		//makeTych(tych_variant, activeDocument);		tpApplyResize(doc);		if (tpSettings.autosave) {			jpgFile = new File(tpSettings.save_directory + '/' + tpSettings.filename);			jpgSaveOptions = new JPEGSaveOptions();			jpgSaveOptions.embedColorProfile = true;			jpgSaveOptions.formatOptions = FormatOptions.STANDARDBASELINE;			jpgSaveOptions.matte = MatteType.NONE;			jpgSaveOptions.quality = tpSettings.jpeg_quality;			app.activeDocument.saveAs(jpgFile, jpgSaveOptions, true, Extension.LOWERCASE);		}		if (tpSettings.autoclose)			doc.close(SaveOptions.DONOTSAVECHANGES);	} else {		alert("You have to open a document to use this script.");		return -1;	}}/** * Makes an horizontal n-tych by spacing out the layers in the specified * document. */function tpNTych(doc){	// Compute the width of the all layers side by side. The width will affect the	// spacing between layers. Wheter aspect ratio is kept or not will affect	// how wide the final image will be thus it will also affect the spacing.	var height = tpSettings.keep_aspect ? tpMinHeight(doc.layers) : null;	var width = tpSumWidthAtHeight(doc.layers, doc.layers.length, height)		var spacing = tpSettings.resize		? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / width))		: tpSettings.spacing;	var size = tpGetSize(doc.layers, spacing);	var trans = tpGetTrans(doc.layers, spacing);	tpArrange(doc, trans);	doc.resizeCanvas(size[0], size[1], AnchorPosition.TOPLEFT);	tpApplyResize(doc);}/** * Computes the dimensions of a horizontally arranged n-tych for the given * layers. */function tpGetSize(layers, spacing){	var minh = tpMinHeight(layers);	if (tpSettings.keep_aspect)		return new Array(tpSumWidthAtHeight(layers, layers.length, minh) + spacing * (layers.length - 1), minh);	else		return new Array(tpSumWidth(layers) + spacing * (layers.length - 1), minh);}/** * Computes the transformation matrix for placing the given layers * horizontally. */function tpGetTrans(layers, spacing){	var trans = new Array();	var minh = tpMinHeight(layers);	var l = layers;	var s;	for (var i = 0; i < layers.length; i++) {		if (tpSettings.keep_aspect) {			s = minh / (l[i].bounds[3].value - l[i].bounds[1].value);			trans.push(				new Array(					new Array(s * 100, s * 100, AnchorPosition.TOPLEFT),					new Array(tpSumWidthAtHeight(l, i, minh) + spacing * i, 0)				)			);		} else {			trans.push(new Array(null, new Array(tpSumWidth(l, i) + spacing * i, -(l[i].bounds[3] - minh) / 2)));		}	}	return trans;}/** * Arranges the layers in the specified documents according to the specified * transformations t. */function tpArrange(doc, t){	for(i = 0; i < doc.layers.length; i++) {		if (i >= t.length) break;				// Check if the layer should be resized.		if (t[i][0] != null)			doc.layers[i].resize(t[i][0][0], t[i][0][1], t[i][0][2]);		// Check if the layer should be moved.		if (t[i][1] != null) {			doc.layers[i].translate(t[i][1][0], t[i][1][1]);		}	}}/** * Makes a tych of the specified variant for a given document. */function makeTych(tych_variant, doc){	var width = Number(doc.width);	var height = Number(doc.height);	var new_size;	var spacing = tpSettings.spacing;	var trans;	var l1 = doc.layers.length > 0 ? doc.layers[0] : null;	var l2 = doc.layers.length > 1 ? doc.layers[1] : null;	var l3 = doc.layers.length > 2 ? doc.layers[2] : null;	var l4 = doc.layers.length > 3 ? doc.layers[3] : null;	// Unlock the background layer, if it exists. We do this because since	// we need to move a layer underneath it later.	tpUnlockBackground(doc);	switch (tych_variant) {		case DIPTYCH_HORIZONTAL:		case TRIPTYCH_HORIZONTAL:		case QUAPTYCH_HORIZONTAL:			var spacing = tpSettings.resize				? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / tpSumWidth(doc.layers)))				: tpSettings.spacing;			var new_size = tpGetSize(doc.layers, spacing);			var trans = tpGetTrans(doc.layers, spacing);			break;		case DIPTYCH_LANDSCAPE_PORTRAIT_HORIZONTAL:		case DIPTYCH_PORTRAIT_LANDSCAPE_HORIZONTAL:			// Index of portrait layer.			var p = doc.layers[0].bounds[2] > doc.layers[1].bounds[2] ? 1 : 0;						// Scale factor.			var s = doc.layers[1 - p].bounds[3] / doc.layers[p].bounds[3];			var resize = new Array(new Array(s * 100, s * 100, AnchorPosition.TOPLEFT), null);			var offset_x = tych_variant == DIPTYCH_LANDSCAPE_PORTRAIT_HORIZONTAL 				? new Array(doc.layers[1 - p].bounds[2] + spacing, 0) : new Array(0, s * doc.layers[p].bounds[2] + spacing);			trans = new Array(				new Array(resize[p], new Array(offset_x[p], 0)),				new Array(resize[1 - p], new Array(offset_x[1 - p], 0))			)			new_size = new Array(doc.layers[1 - p].bounds[2] + doc.layers[p].bounds[2] * s + spacing, doc.layers[1 - p].bounds[3]);			break;		case TRIPTYCH_PORTRAIT_LANDSCAPE_GRID:		case TRIPTYCH_LANDSCAPE_PORTRAIT_GRID:			// Index of portrait layer.			var p = doc.layers[0].bounds[3] > doc.layers[1].bounds[3] ? 0 : 2;			p = doc.layers[1].bounds[3] > doc.layers[2].bounds[3] ? 1 : p;			var spacing = tpSettings.resize				? Math.ceil(tpSettings.spacing / ((tpSettings.resize_width - tpSettings.spacing) / (doc.layers[p].bounds[2] * 2)))				: tpSettings.spacing;			trans = new Array(				new Array(null, new Array(0, 0)),				new Array(null, new Array(0, 0)),				new Array(null, new Array(0, 0))			)			var l;			if (p == 0)				l = new Array(1, 2);			else if (p == 1)				l = new Array(0, 2);			else				l = new Array(0, 1);			var offsetx = tych_variant == TRIPTYCH_PORTRAIT_LANDSCAPE_GRID ? doc.layers[p].bounds[2] + spacing : 0;			// Transformations for the first landscape image.			var s1 = doc.layers[p].bounds[2] / doc.layers[l[0]].bounds[2];			trans[l[0]] = new Array(				new Array(100 * s1, 100 * s1, AnchorPosition.TOPLEFT),				new Array(offsetx, 0)			);			// Transformations for the second landscape image.			var s2 = doc.layers[p].bounds[2] / doc.layers[l[1]].bounds[2];			trans[l[1]] = new Array(				new Array(100 * s2, 100 * s2, AnchorPosition.TOPLEFT),				new Array(offsetx, doc.layers[l[0]].bounds[3] * s1 + spacing)			);			// XXX: It would be better if the landscape images were adjusted			// vertically so that the seam is centered as much as the images			// allow.			new_size = new Array(				doc.layers[p].bounds[2].value * 2 + spacing,				Math.min(doc.layers[l[0]].bounds[3].value * s1 + doc.layers[l[1]].bounds[3].value * s2 + spacing, doc.layers[p].bounds[3].value)			);			trans[p][1][0] = tych_variant == TRIPTYCH_PORTRAIT_LANDSCAPE_GRID ? 0 : doc.layers[p].bounds[2] + spacing;			trans[p][1][1] = -(doc.layers[p].bounds[3] - new_size[1]) / 2;			break;		case QUAPTYCH_GRID:			var col1_width = Math.max(l1.bounds[2], l3.bounds[2]);			var col2_width = Math.max(l2.bounds[2], l4.bounds[2]);			var row1_height = Math.max(l1.bounds[3], l2.bounds[3]);			var row2_height = Math.max(l3.bounds[3], l4.bounds[3]);			trans = new Array(				new Array(null, null),				new Array(null, new Array(col1_width + spacing, 0)),				new Array(null, new Array(0, row1_height + spacing)),				new Array(null, new Array(col1_width + spacing, row1_height + spacing))			)			new_size = new Array(col1_width + col2_width + spacing, row1_height + row2_height + spacing);			break;		default:			return -1;	}	// Transform each layer according to the transformations specified in	// the trans variable.	tpArrange(doc, trans);		doc.resizeCanvas(new_size[0], new_size[1], AnchorPosition.TOPLEFT);	// Create a layer, put it last and it white.	var fillLayer = doc.artLayers.add();	fillLayer.move(doc.layers[doc.layers.length - 1], ElementPlacement.PLACEAFTER);	tpFillBackground(doc, WHITE);}/** * Resizes the specified document according to the user settings. */function tpApplyResize(doc){	if (tpSettings.resize) {		var resampleMethod = tpSettings.resample_method == 'bicubic' ? ResampleMethod.BICUBIC : ResampleMethod.BICUBICSHARPER;		doc.resizeImage(tpSettings.resize_width, tpSettings.resize_width * doc.height / doc.width, 1, resampleMethod);	}}/** * Make a background layer and fill it with the specified color. */function tpFillBackground(doc, color){	var al = doc.activeLayer;	var fillColor = new SolidColor();	fillColor.rgb.red = color[0];	fillColor.rgb.green = color[1];	fillColor.rgb.blue = color[2];		doc.activeLayer = doc.layers[doc.layers.length - 1];	doc.selection.fill(fillColor)	doc.activeLayer = al;}/** * Add a background layer and fill it with the specified color. */function tpAddBackground(doc, color){	tpUnlockBackground(doc);	doc.activeLayer = doc.layers[doc.layers.length - 1];	var fillLayer = doc.artLayers.add();	fillLayer.name = 'Background';	fillLayer.move(doc.layers[doc.layers.length - 1], ElementPlacement.PLACEAFTER);	tpFillBackground(doc, color);}/** * Unlocks the background layer of the given or active document. */function tpUnlockBackground(doc){	var ad = activeDocument;	var d = doc == null ? activeDocument : doc;	activeDocument = d;	if (d.artLayers[d.layers.length - 1].isBackgroundLayer) {		d.artLayers[d.layers.length - 1].copy();		var pasted = d.paste();		d.artLayers[d.layers.length - 1].remove();		pasted.move(d.layers[d.layers.length - 1], ElementPlacement.PLACEAFTER);	}	// Restore active document.	activeDocument = ad;}/** * Computes the total width of the specified layers. */function tpSumWidth(layers, max){	var totalWidth = 0;	for (var i = 0; i < layers.length; i++) {		if (max != null && i == max) break;		totalWidth += layers[i].bounds[2].value - layers[i].bounds[0].value;	}	return totalWidth;}/** * Computes the total width of the specified layers as if they were scaled * (keeping aspect ratio) to fit the specified height. */function tpSumWidthAtHeight(layers, max, height) {	if (height == null) return tpSumWidth(layers, max);	var totalWidth = 0;	var s;	for (var i = 0; i < layers.length; i++) {		if (max != null && i == max) break;		s = height / (layers[i].bounds[3].value - layers[i].bounds[1].value);		totalWidth += s * (layers[i].bounds[2].value - layers[i].bounds[0].value);	}	return totalWidth;}/** * Gets the height of the shortest of the specified layers. */function tpMinHeight(layers){	var minWidth = Number.MAX_VALUE;	for (var i = 0; i < layers.length; i++)		minWidth = Math.min(minWidth, layers[i].bounds[3].value - layers[i].bounds[1].value);	return minWidth;}/** * Translates the specified tych variant constant into a human friendly string * for the history palette. */function tpTychToHistoryName(tych_variant){	switch (tych_variant) {		case DIPTYCH_HORIZONTAL:		case DIPTYCH_LANDSCAPE_PORTRAIT_HORIZONTAL:		case DIPTYCH_PORTRAIT_LANDSCAPE_HORIZONTAL:			return 'Create diptych';		case TRIPTYCH_HORIZONTAL:		case TRIPTYCH_PORTRAIT_LANDSCAPE_GRID:		case TRIPTYCH_LANDSCAPE_PORTRAIT_GRID:			return 'Create triptych';		case QUAPTYCH_HORIZONTAL:		case QUAPTYCH_GRID:			return 'Create quaptych';	}}