//@include constants.jsx//@include settings.jsx//@include reorder.jsx//@include helpers.jsx//@include TychTransformations.jsx//@include layerMaskLib.9.jsx/* * Tych constructor. */var Tych = function(settings){	//this.tych_variant = NTYCH_HORIZONTAL;	// Save current unit preferences.	this.rulerUnits = preferences.rulerUnits;	// Change unit preferences.	preferences.rulerUnits = Units.PIXELS;	// Save a reference to the current open document if there is one.	// New layouts may be merged and composited into this document later.	this.comp_target_doc = documents.length > 0 ? activeDocument : null;	this.settings = settings;}/** * Select the images that should be part of this Tych. */Tych.prototype.select = function(){	var images, thumbs;	// Use bridge selection if there is one.	if (this.settings.use_bridge_selection && BridgeTalk.isRunning('bridge')) {		var bridge_selection = tp_get_bridge_selection();		images = bridge_selection[0];		thumbs = bridge_selection[1];	}	if (images == undefined || images.length < 1)		images = File.openDialog("Choose file(s) to add to composite", undefined, true);	if (images != undefined && images.length > 1 && this.settings.reorder)		images = tp_reorder(images, thumbs);	if (images == undefined || images.length < 1) {		// No images were selected or the reorder window was dismissed. Revert		// settings and stop the script.		this.revert();		return false;	}	// If the user opens a file that is already open we will have a document	// collision problem. To solve it we duplicate the open, colliding document	// to get a copy of it with a new name. We then close the original	// document.	for (i in images) {		try {			var docc = documents.getByName(images[i].name);			this.comp_target_doc = docc.duplicate();			docc.close(SaveOptions.DONOTSAVECHANGES);		} catch (err) { }	}	this.images = images;	return true;}Tych.prototype.revert = function(){	preferences.rulerUnits = this.rulerUnits;}/** * Stack the images of this Tych instance. */Tych.prototype.stack = function(){	var tych = this;	var last = this.images.length - 1;	var doc = app.open(this.images[last]);	f = function() {		var d = doc;		var maxx = doc.width;		var maxy = doc.height;		d.flatten();		d.layers[0].isBackgroundLayer = false;		if (tych.settings.convert_to_smartobject)			tp_make_smart_object();		for (i = last; i >= 0; i--) {			if (i < last) {				d = app.open(tych.images[i]);				d.flatten();				d.selection.selectAll();				if (d.layers.length > 1)					d.selection.copy(true);				else					d.selection.copy();				maxx = Math.max(maxx, d.width);				maxy = Math.max(maxy, d.height);				d.close(SaveOptions.DONOTSAVECHANGES);				activeDocument = doc;				doc.paste();				doc.layers[0].translate(-doc.layers[0].bounds[0].value, -doc.layers[0].bounds[1].value);				if (tych.settings.convert_to_smartobject)					tp_make_smart_object();			}		}		doc.resizeCanvas(maxx, maxy, AnchorPosition.TOPLEFT);		// If mask option is enabled, add a layer mask to each layer.		if (tych.settings.mask_layers)			for (i = 0; i < doc.layers.length; i++)				tp_mask(doc.layers[i]);	}	doc.suspendHistory('Stack images', 'f()');	this.doc = doc;	this.n = doc.layers.length;	this.trans = new TychTransformations(this);}// XXX: I should remove this method and instead use the same method for both// templates and ntychs. If the active document already has layers laid out,// the templates should add them just like New row and New column (if enabled// in the gui).Tych.prototype.create = function(tych_variant){	this.tych_variant = tych_variant;	if (documents.length < 1) {		this.select();		var required = this.validate_input(tych_variant, this.images.length);		if (required > this.images.length) {			alert('This action requires that you select ' + required + ' images. Please try again.');			this.revert();			return -1;		}		// Stack it up.		this.stack();	} else {		var d = activeDocument;		var required = -1;		var required = this.validate_input(tych_variant, d.layers.length);		// Check if this is a tych that's already been laid out once.		if (d.layers.length == required + 1) {			this.finish();			return;		}		// Ugly workaround for Windows bug. If we use the original document		// weird things start to happen for no apparent reason. So we use a		// duplicate instead.		this.doc = d.duplicate();		this.comp_target_doc = null;		d.close(SaveOptions.DONOTSAVECHANGES);		if (required > this.doc.layers.length) {			alert('This action requires ' + required + ' layers. Stack some more layers then try again.');			this.revert();			return -1;		}	}	// Compute transformations (prepare for layout).	this.trans.compute(tych_variant);	// Layout the selected images.	this.layout();	// Save, close etc.	this.finish();}Tych.prototype.validate_input = function(tych_variant, number){	var required = -1;	if (tych_variant < 3)		required = 2;	else if (tych_variant > 2 && tych_variant < 6)		required = 3;	else		required = 4;	return required;}Tych.prototype.finish = function(){	// Make a reference to the document that should be saved.	this.save_doc = this.comp_target_doc == null ? this.doc : this.comp_target_doc;		// Unlink all layer masks.	if (this.save_doc.layerSets.length > 0) {		for (var i = 0; i < this.save_doc.layerSets.length; i++) {			for (var j = 0; j < this.save_doc.layerSets[i].layers.length; j++) {				this.save_doc.activeLayer = this.save_doc.layerSets[i].layers[j];				layerMask.link(false);			}		}	} else {		for (var i = 0; i < this.save_doc.layers.length; i++) {			this.save_doc.activeLayer = this.save_doc.layers[i];			layerMask.link(false);		}	}	if (this.save_doc.layers[this.save_doc.layers.length - 1].name == 'Background')		tp_fill_background(this.save_doc, WHITE);	else 		tp_add_background(this.save_doc, WHITE);	if (this.settings.autosave)		this.save(this.save_doc);		if (this.settings.autoclose)		this.save_doc.close(SaveOptions.DONOTSAVECHANGES);	// Revert settings.	this.revert();}Tych.prototype.layout_and_composite = function(tych_variant){	this.tych_variant = tych_variant;	// Select the images to layout.	if (!this.select()) {		// Abort if no images are selected.		this.revert();		return;	}		// Stack it up.	this.stack();	var thiss = this;	var g = function() {		// Compute transformations (prepare for layout).		thiss.trans.compute(tych_variant);				// Layout the selected images according to the transformations just		// computed.		thiss.layout();		// Composite the result.		if (thiss.settings.composite && thiss.comp_target_doc != null)			if (tych_variant == NTYCH_VERTICAL)				thiss.composite(thiss.doc, thiss.comp_target_doc, { side: RIGHT });			else				thiss.composite(thiss.doc, thiss.comp_target_doc, { side: BOTTOM });		//// Save, close etc.		thiss.finish();	}	this.doc.suspendHistory('Make ntych', 'g()');}/** * Places the contents of one document at the bottom of another. */Tych.prototype.composite = function(src, target, options){	var i,		placement,		src_width,		src_height,		target_width,		target_height,		layer_set,		layers_to_move,		inserted_set;	// Store away the width & height of the source document before we close it.	src_width = src.width;	src_height = src.height;	// Store away the width & height of the target document before we resize the canvas.	target_width = target.width.value;	target_height = target.height.value;	activeDocument = target;	// Get rid of outside pixels;	//target.crop([0, 0, target.width, target.height]);	if (target.layerSets.length == 0) {		layers_to_move = [];		for (i = 0; i < target.layers.length - 1; i++)			layers_to_move[i] = target.layers[i];		layer_set = target.layerSets.add();		if (this.tych_variant == NTYCH_HORIZONTAL)			layer_set.name = 'Row';		else if (this.tych_variant == NTYCH_VERTICAL)			layer_set.name = 'Column';		else			layer_set.name = 'Comp';		this.move_into_set(layers_to_move, layer_set);	}	inserted_set = target.layerSets.add();	if (this.tych_variant == NTYCH_HORIZONTAL)		inserted_set.name = 'Row';	else if (this.tych_variant == NTYCH_VERTICAL)		inserted_set.name = 'Column';	else		inserted_set.name = 'Comp';	target.activeLayer = inserted_set;	// Unlock the background (if locked) so we can put a background fill below.	target.layers[target.layers.length - 1].isBackgroundLayer = false;	for (i = 0; i < src.layers.length; i++)		this.copy_layer_to_document(src.layers[i], target);	//return;	layers_to_move = [];	for (i = 0; i < src.layers.length; i++)		layers_to_move[i] = target.layers[i];	this.move_into_set(layers_to_move, inserted_set);	src.close(SaveOptions.DONOTSAVECHANGES);	/*	activeDocument = target;	target.activeLayer = target.layers[0];		*/	activeDocument = target;	if (options.side == BOTTOM) {		offset_x = 0;		offset_y = target.height + this.settings.spacing;		new_width = target.width.value;		new_height = target.height.value + src_height + this.settings.spacing;	} else if (options.side == RIGHT) {		offset_x = target.width.value - target.activeLayer.bounds[0].value + this.settings.spacing;		offset_y = 0;		new_width = target.width.value + src_width + this.settings.spacing;		new_height = target.height.value;	}	inserted_set.translate(offset_x, offset_y);	target.resizeCanvas(new_width, new_height, AnchorPosition.TOPLEFT);	// Maintain width & height.	if (this.settings.maintain_width) {		if (this.tych_variant != NTYCH_HORIZONTAL) {			// We need to make the layers less wide in order to fit the new pictures.			target.resizeImage(target_width, target_width / new_width * target_height);			this.clear_spacings(target);		}	} else if (this.settings.maintain_height) {		if (this.tych_variant != NTYCH_VERTICAL) {			// We need to make the layers less high in order to fit the new pictures.			target.resizeImage(target_height / new_height * target_width, target_height);		}	}	//$.writeln('resize to: ' + target_height / new_height * target_width + ' x ' + target_height);	//$.writeln('maintain width: ' + this.settings.maintain_width);	//$.writeln('maintain height: ' + this.settings.maintain_height);			}/** * * Gets the corners of the rectangle that fills the space between two layers * given the bounds of said layers. *  */function spacing_corners(b1, b2, width) {	var u0, u1, v0, v1, x0, x1, y0, y1, r0, r1;	r0 = Math.floor(width / 2)	r1 = Math.ceil(width / 2)	x0 = Math.round(b1[0].value);	x1 = Math.round(b1[2].value);	y0 = Math.round(b1[1].value);	y1 = Math.round(b1[3].value);	u0 = Math.round(b2[0].value);	u1 = Math.round(b2[2].value);	v0 = Math.round(b2[1].value);	v1 = Math.round(b2[3].value);	// b1 is on top of b2.	if (y1 < v0 ) {		// Spacing center in y.		var sy = Math.round((v0 - y1) / 2) + y1;		return [[x0, sy - r0], [x0, sy + r1], [x1, sy + r1], [x1, sy - r0]];	//} else {		//// Spacing center in y.		//var sy = Math.round((y0 - v1) / 2 + v1);		//return [[u0, sy - width / 2], [u0, sy + width / 2], [u1, sy + width / 2], [u1, sy - width / 2]];	}			// b1 is to the left of b2.	if (u0 < x1) {		// Spacing center in x.		var sx = Math.round((u0 - x1) / 2 + x1);		return [[sx - r0, y0], [sx - r0, y1], [sx + r1, y1], [sx + r1, y0]];	}	}//var sel = spacing_corners(activeDocument.layers[1].bounds, activeDocument.layers[0].bounds, 10);//activeDocument.selection.select(sel);//$.writeln(sel);Tych.prototype.clear_spacings = function(doc){		var spacing = this.settings.spacing;	var width = doc[0];	var height = doc[1];	var sel = [];	var s, l;	for (var i = 0; i < doc.layerSets.length; i++) {	$.writeln('--------');		s = doc.layerSets[i];		for (var j = 0; j < s.layers.length - 1; j++) {						var sel = spacing_corners(s.layers[j].bounds, s.layers[j + 1].bounds, this.settings.spacing);			$.writeln(sel);			doc.selection.select(sel);			// Clear the selection.			if (this.settings.mask_layers) {				//doc.activeLayer = l;				doc.activeLayer = s.layers[j];				tp_fill_layer_mask(BLACK);				doc.activeLayer = s.layers[j + 1];				tp_fill_layer_mask(BLACK);			} else {				doc.activeLayer = s.layers[j];				doc.selection.clear();				doc.activeLayer = s.layers[j + 1];				doc.selection.clear();			}			//exit();			//		}	}	doc.selection.deselect();	/*	for (var i = 0; i < doc.layerSets.length; i++) {		s = doc.layerSets[i];		for (var j = 0; j < s.layers.length; j++) {			//$.writeln(s.layers[j].name);			l = s.layers[j];			doc.activeLayer = l;			//$.writeln('name:' + l.name);				// Spacing above.			if (l.bounds[1].value > 0)				sel.push([					[l.bounds[0].value - 1, l.bounds[1].value + 1 - spacing], // Upper left corner.					[l.bounds[0].value - 1, l.bounds[1].value + 1], // Lower left corner.					[l.bounds[2].value - 1, l.bounds[1].value + 1], // Lower right corner.					[l.bounds[2].value - 1, l.bounds[1].value + 1 - spacing] // Upper right corner.				]);			// Spacing to the right.			if (l.bounds[2].value < doc.width)				sel.push([					[l.bounds[2].value - 1, l.bounds[1].value - 1], // Upper left corner.					[l.bounds[2].value - 1, l.bounds[3].value - 1], // Lower left corner.					[l.bounds[2].value - 1 + spacing, l.bounds[3].value + 1], // Lower right corner.					[l.bounds[2].value - 1 + spacing, l.bounds[1].value + 1] // Upper right corner.				]);			// Spacing below.			if (l.bounds[3].value < doc.height)				sel.push([					[l.bounds[0].value - 1, l.bounds[3].value - 1], // Upper left corner.					[l.bounds[0].value - 1, l.bounds[3].value - 1 + spacing], // Lower left corner.					[l.bounds[2].value + 1, l.bounds[3].value - 1 + spacing], // Lower right corner.					[l.bounds[2].value + 1, l.bounds[3].value - 1] // Upper right corner.				]);						// Spacing to the left.			if (l.bounds[0].value > 0)				sel.push([					[l.bounds[0].value + 1 - spacing, l.bounds[1].value - 1], // Upper left corner.					[l.bounds[0].value + 1 - spacing, l.bounds[3].value + 1], // Lower left corner.					[l.bounds[0].value + 1, l.bounds[3].value + 1], // Lower right corner.					[l.bounds[0].value + 1, l.bounds[1].value - 1] // Upper right corner.				]);			for (var k = 0; k < sel.length; k++) {				doc.selection.select(sel[k]);				//$.writeln(k);				// Clear the selection.				if (this.settings.mask_layers)					tp_fill_layer_mask(BLACK);				else					doc.selection.clear();			}			doc.selection.deselect();			//exit();		}	}	*/}/** * Saves the specified document according to the output options set in the * options dialog. If any of the files already exist the sequence number will * be incremented. * * For example: Assume that the options are set to output both jpg and psd * files with the file name set to "image". If the file image_001.jpg already * exists, then the files will be saved to image_002.jpg and image_002.psd so * that nothing is overwritten. */Tych.prototype.save = function(){	var basename = this.settings.filename + '_';	var padding = '001';	var collision;	var file;	while(true) {		collision = false;		for (format in this.settings.output_formats) {			file = new File(this.settings.save_directory + '/' + basename + padding + '.' + format);			if (file.exists) {				collision = true;				break;			}		}		// Increase the sequential number by 1 if there is a file name collision.		if (collision)			padding = tp_zero_pad(Number(padding) + 1, 3);		else			break;	}	var options = {		'jpg': this.get_jpeg_save_options(),		'psd': this.get_psd_save_options()	};	for (format in this.settings.output_formats)		if (this.settings.output_formats[format])			this.save_doc.saveAs(				new File(this.settings.save_directory + '/' + basename + padding),				options[format], true, Extension.LOWERCASE);}/** * Makes an horizontal n-tych by spacing out the layers in the specified * document. */Tych.prototype.layout = function(){	this.trans.apply();	// Get rid of outside pixels;	//this.save_doc = this.comp_target_doc == null ? this.doc : this.comp_target_doc;	this.doc.crop([0, 0, this.doc.width, this.doc.height]);}/**  * Clears the selected area on all layers. * * If masks are enabled, layers are cleared by masking out the selected parts. *///Tych.prototype.clear_selected = function()//{	//for (j = 0; j < this.n; j++) {		//this.doc.activeLayer = this.doc.layers[j];		//if (tp_overlaps_selection(this.doc.activeLayer))			//if (this.settings.mask_layers)				//tp_fill_layer_mask(BLACK);			//else				//this.doc.selection.clear();	//}	//this.doc.selection.deselect();//}Tych.prototype.get_jpeg_save_options = function(){	options = new JPEGSaveOptions();	options.embedColorProfile = true;	options.formatOptions = FormatOptions.STANDARDBASELINE;	options.matte = MatteType.NONE;	options.quality = this.settings.jpeg_quality;	return options;}Tych.prototype.get_psd_save_options = function(){	options = new PhotoshopSaveOptions();	options.layers = true;	options.embedColorProfile = true;	options.annotations = true;	options.alphaChannels = true;	options.spotColors = true;	return options;}Tych.prototype.move_into_set = function(layers, set){	activeDocument = layers[0].parent;	for (i = 0; i < layers.length; i++)		layers[i].move(set, ElementPlacement.INSIDE);}/*Tych.prototype.test_copy = function(){	var i;	for (i = 0; i < activeDocument.layers.length; i++) {		//src.activeLayer = src.layers[i];		$.writeln(i + ' hhj');		this.copy_layer_to_document(activeDocument.layers[i], documents[0]);		$.writeln(i + ' say what');	}}*//** * Copies the specified layer to the bottom of the layer stack of the given * document. */Tych.prototype.copy_layer_to_document = function(layer, target){	activeDocument = layer.parent;	var temp = layer.parent.activeLayer;	layer.parent.activeLayer = layer;	for (i = 0; i < documents.length; i++) {		if (documents[i] == target)			target_index = i;		if (documents[i] == activeDocument)			active_index = i;	}	// We must iterate through the document stack in order to copy the layer to	// a specific document. It works by copying it one document at a time until	// it's in the right document.	for (i = active_index; i >= target_index; i--) {		this.copy_layer_to_previous_document();		if (i != active_index)			// Remove when not the in target			documents[i].activeLayer.remove();		if (i - 1 == target_index) break;		activeDocument = documents[i - 1];	}	activeDocument = layer.parent;	layer.parent.activeLayer = temp;}/** * Copies the active layer of the active document to the document beneath it * in the document stack. */Tych.prototype.copy_layer_to_previous_document = function(){	var desc = new ActionDescriptor();	var ref = new ActionReference();	ref.putEnumerated(		charIDToTypeID('Lyr '),		charIDToTypeID('Ordn'),		charIDToTypeID('Trgt')	);	desc.putReference(charIDToTypeID('null'), ref);	var docRef = new ActionReference();	docRef.putOffset(charIDToTypeID('Dcmn'), -1);	desc.putReference(charIDToTypeID('T   '), docRef);	desc.putInteger(charIDToTypeID('Vrsn'), 5);	executeAction(charIDToTypeID('Dplc'), desc, DialogModes.NO);}var t = new Tych(tp_get_settings());//t.create(QUAPTYCH_GRID);//t.create(TRIPTYCH_PORTRAIT_LANDSCAPE_GRID);//t.create(TRIPTYCH_LANDSCAPE_PORTRAIT_GRID);//t.create(QUAPTYCH_GRID);//t.layout_and_composite(NTYCH_HORIZONTAL);//t.layout_and_composite(NTYCH_VERTICAL);//t.test_copy();